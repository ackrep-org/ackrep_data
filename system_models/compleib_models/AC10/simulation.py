# This file was autogenerated from the template: simulation.py.template (2022-10-10 15:53:22).

import numpy as np
import system_model
from scipy.integrate import solve_ivp, odeint

from ackrep_core import ResultContainer
from ackrep_core.system_model_management import save_plot_in_dir
import matplotlib.pyplot as plt
import os
from ipydex import Container

# link to documentation with examples: https://ackrep-doc.readthedocs.io/en/latest/devdoc/contributing_data.html


def simulate():
    """
    simulate the system model with scipy.integrate.solve_ivp

    :return: result of solve_ivp, might contains input function
    """

    model = system_model.Model()

    rhs_xx_pp_symb = model.get_rhs_symbolic()
    rhs = model.get_rhs_func()

    # initial state values
    xx0 = np.ones(model.sys_dim)

    t_end = 10
    tt = np.linspace(0, t_end, 1000)

    simulation_data = solve_ivp(rhs, (0, t_end), xx0, t_eval=tt)

    # using odeint for models with large state vectors
    # res = odeint(rhs, y0=xx0, t=tt, tfirst=True)
    # simulation_data = Container()
    # simulation_data.y = res.transpose()
    # simulation_data.t = tt

    # postprocessing: calc output
    ny = 2
    C = model.get_parameter_value("C")
    D21 = model.get_parameter_value("D21")
    output = np.zeros((ny, len(tt)))
    for i in range(len(tt)):
        output[:,i] = np.matmul(C, simulation_data.y[:,i]) # + np.matmul(D21, w)
    simulation_data.output = output

    save_plot(simulation_data)

    return simulation_data


def save_plot(simulation_data):
    """
    plot your data and save the plot
    access to data via: simulation_data.t   array of time values
                        simulation_data.y   array of data components
                        simulation_data.uu  array of input values

    :param simulation_data: simulation_data of system_model
    :return: None
    """

    for i in range(simulation_data.output.shape[0]):
        plt.plot(simulation_data.t, simulation_data.output[i], label=f"$y_{i}$")

    plt.legend()
    plt.tight_layout()

    save_plot_in_dir()


def evaluate_simulation(simulation_data):
    """
    assert that the simulation results are as expected

    :param simulation_data: simulation_data of system_model
    :return:
    """
    expected_final_state = np.array([-6.93273736e+02,  6.42161845e+03, -6.69320262e+02, -1.36619917e+02,
       -1.09300667e+00,  1.68775945e-01, -5.38584759e+00, -2.61244474e+00,
        1.40770251e-02, -1.55499865e-02, -2.66001758e-02, -5.94735449e-02,
       -5.04499124e-03,  5.08720133e-03, -9.70641644e-03, -8.12229831e-03,
       -5.49236856e-04,  3.43409777e-04,  5.49155270e-04,  1.63899684e-03,
       -5.67722419e-04, -2.26355253e-05, -4.22939705e-04, -1.51118067e-04,
        9.91463770e-03,  3.77013369e-03,  4.61130659e-04,  2.96312392e-03,
       -8.56018653e-03,  1.51494768e-04, -1.88834371e-04, -1.78314140e-03,
       -1.06902068e-03,  1.33322909e-02, -1.82119647e-02, -5.15592665e-05,
       -2.65596896e-04,  1.55314959e-04, -9.63935160e-05,  6.02008750e-04,
       -9.42600688e-05, -2.37247303e-07,  2.06367042e-05, -1.73187797e-02,
       -5.70878535e-03,  1.30207611e-12, -1.30207611e-09,  1.30207611e-06,
        1.30207611e-12, -1.30207611e-09,  1.30207611e-06,  1.99640588e-02,
        3.33150229e-02,  1.38389664e-87,  1.38389664e-87])

    rc = ResultContainer(score=1.0)
    simulated_final_state = simulation_data.y[:, -1]
    rc.final_state_errors = [
        simulated_final_state[i] - expected_final_state[i] for i in np.arange(0, len(simulated_final_state))
    ]
    rc.success = np.allclose(expected_final_state, simulated_final_state, rtol=0, atol=1e-2)

    return rc